<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dynamic Linear Inequalities (No Duplicates)</title>
<style>
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: #f4f6f9; color: #333; display: flex; justify-content: center; min-height: 100vh; padding: 20px; }
    .container { background: white; width: 100%; max-width: 850px; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); }
    
    /* Stats Bar */
    .stats-bar { display: flex; justify-content: space-between; background: #eef2f5; padding: 12px 20px; border-radius: 8px; margin-bottom: 25px; font-weight: 600; color: #555; border-bottom: 3px solid #dfe6ed; }
    
    /* Typography */
    .question-box { font-size: 1.25em; margin-bottom: 25px; line-height: 1.5; color: #2c3e50; }
    .math-text { font-family: 'Courier New', monospace; font-weight: bold; background: #f1f3f5; padding: 2px 6px; border-radius: 4px; color: #d63384; font-size: 1.1em; }
    
    /* Grid & Graph Layouts */
    .graph-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
    .graph-option { border: 3px solid #eee; border-radius: 8px; overflow: hidden; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; background: white; text-align: center; padding-bottom: 10px; }
    .graph-option:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-color: #cbd5e0; }
    .graph-option.selected { border-color: #3498db; background-color: #f0f7fb; transform: scale(1.02); }
    .graph-label { padding: 5px; font-weight: bold; color: #7f8c8d; font-size: 1.1em; }
    
    /* SVG Styling */
    svg { background: #fff; display: block; margin: 0 auto; user-select: none; }
    .grid-line { stroke: #e0e0e0; stroke-width: 1; }
    .axis-line { stroke: #333; stroke-width: 2; }
    .tick-text { font-size: 10px; fill: #666; font-family: sans-serif; }
    
    /* Text Multiple Choice */
    .mc-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
    .mc-text-option { background: #f8f9fa; border: 2px solid #ddd; padding: 15px; border-radius: 8px; cursor: pointer; font-size: 1.1em; transition: 0.2s; display: flex; align-items: center; }
    .mc-text-option:hover { background: #e9ecef; }
    .mc-text-option.selected { background: #d4eaf7; border-color: #3498db; }
    .mc-letter { font-weight: bold; color: #7f8c8d; margin-right: 10px; min-width: 25px; }
    
    /* Buttons */
    .btn-group { display: flex; gap: 10px; margin-top: 20px; }
    .btn { flex: 1; background-color: #3498db; color: white; border: none; padding: 14px; font-size: 1.1em; border-radius: 6px; cursor: pointer; font-weight: 600; transition: background 0.2s; }
    .btn:hover { background-color: #2980b9; }
    .btn.secondary { background-color: #95a5a6; }
    .btn.secondary:hover { background-color: #7f8c8d; }
    
    /* Feedback */
    .feedback { margin-top: 25px; padding: 20px; border-radius: 8px; display: none; animation: fadeIn 0.3s ease-in; }
    .feedback.correct { background: #d1e7dd; color: #0f5132; border: 1px solid #badbcc; }
    .feedback.incorrect { background: #f8d7da; color: #842029; border: 1px solid #f5c2c7; }
    .solution-step { margin-top: 10px; padding-left: 15px; border-left: 3px solid rgba(0,0,0,0.1); font-size: 0.95em; white-space: pre-wrap; line-height: 1.6; }
    
    .hidden { display: none !important; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
</style>
</head>
<body>

<div class="container">
    <div class="stats-bar">
        <span>Question <span id="q-num">1</span> of <span id="total-q">5</span></span>
        <span>Score: <span id="score-correct">0</span></span>
    </div>

    <div id="quiz-area">
        <div class="question-box" id="question-text"></div>
        
        <div id="dynamic-content"></div>
        
        <div class="btn-group">
            <button class="btn" id="submit-btn" onclick="checkAnswer()">Check Answer</button>
            <button class="btn hidden" id="next-btn" onclick="nextQuestion()">Next Question</button>
        </div>
        
        <div class="feedback" id="feedback-area">
            <strong id="feedback-title" style="font-size: 1.2em;"></strong>
            <div class="solution-step" id="solution-text"></div>
        </div>
    </div>

    <div id="summary-area" class="hidden">
        <h2 style="text-align:center; color: #2c3e50;">Quiz Complete!</h2>
        <div style="font-size: 3em; text-align: center; color: #2c3e50; margin: 30px 0; font-weight: bold;">Score: <span id="final-score"></span></div>
        <button class="btn" onclick="startNewQuiz()">Generate New Numbers</button>
    </div>
</div>

<script>
/**
 * ROBUST INEQUALITIES ENGINE
 * Features: Collision Detection, Unique Option Generation, 1:1 Scaling
 */

// --- CONFIGURATION ---
const GRID_RANGE = 6; // -6 to 6
const GRID_SIZE_PX = 240; 
const PADDING = 25;

// --- STATE MANAGEMENT ---
let currentQIndex = 0;
let score = 0;
let currentQData = {};
const TOTAL_QUESTIONS = 5;

// --- UTILITY FUNCTIONS ---
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

// Logic to format equation cleanly
function fmtEq(m, b, sym) {
    let mStr = "";
    if (m === 1) mStr = "x";
    else if (m === -1) mStr = "-x";
    else mStr = `${m}x`;
    
    let bStr = "";
    if (b > 0) bStr = `+ ${b}`;
    else if (b < 0) bStr = `- ${Math.abs(b)}`;
    
    // Edge case: if b is 0 and we have mx
    if (b === 0 && mStr !== "") bStr = "";
    // Edge case: if m is 0 (y > 4)
    if (m === 0) {
        mStr = "";
        if (b >= 0) bStr = `${b}`;
        else bStr = `${b}`; // Should handle negative naturally
    }
    
    return `y ${sym} ${mStr} ${bStr}`;
}

// --- DEDUPING LOGIC ---
// Generates 3 unique distractors that are NOT equal to the answer or each other
function generateDistractors(correctM, correctB, correctSym) {
    const correctEq = fmtEq(correctM, correctB, correctSym);
    const optionsSet = new Set();
    optionsSet.add(correctEq); // Add correct answer to set to prevent duplication
    
    const distractors = [];
    
    // Strategy Pool: Functions that attempt to create a unique distractor
    const strategies = [
        // 1. Flip Symbol (Shading)
        () => {
            let s = correctSym.includes('<') ? correctSym.replace('<', '>') : correctSym.replace('>', '<');
            return { m: correctM, b: correctB, s: s };
        },
        // 2. Flip Slope Sign
        () => {
            return { m: -1 * correctM, b: correctB, s: correctSym };
        },
        // 3. Flip Intercept Sign (Only effective if b != 0)
        () => {
            return { m: correctM, b: -1 * correctB, s: correctSym };
        },
        // 4. Change Intercept Value (+1 or -1)
        () => {
             let newB = (correctB >= 5) ? correctB - 2 : correctB + 2;
             return { m: correctM, b: newB, s: correctSym };
        },
        // 5. Change Slope Value
        () => {
            let newM = (correctM > 0) ? correctM + 1 : correctM - 1;
            if(newM === 0) newM = 2; 
            return { m: newM, b: correctB, s: correctSym };
        },
        // 6. Flip Line Style (Strict vs Equal)
        () => {
            let s = "";
            if(correctSym === '<') s = '≤';
            else if(correctSym === '≤') s = '<';
            else if(correctSym === '>') s = '≥';
            else s = '>';
            return { m: correctM, b: correctB, s: s };
        }
    ];

    // Try strategies until we have 3 distinct distractors
    for (let strategy of strategies) {
        if (distractors.length >= 3) break;
        
        let d = strategy();
        let dStr = fmtEq(d.m, d.b, d.s);
        
        if (!optionsSet.has(dStr)) {
            optionsSet.add(dStr);
            distractors.push({ ...d, text: dStr });
        }
    }
    
    return distractors;
}

// --- SVG GRAPHING ENGINE (SCALED 1:1) ---
function generateGraph(m, b, symbol, size = GRID_SIZE_PX) {
    const minVal = -GRID_RANGE, maxVal = GRID_RANGE;
    const w = size, h = size;
    
    const scaleX = x => PADDING + ((x - minVal) / (maxVal - minVal)) * (w - 2*PADDING);
    const scaleY = y => (h - PADDING) - ((y - minVal) / (maxVal - minVal)) * (h - 2*PADDING);

    let svg = `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;

    // Grid
    for(let i = minVal; i <= maxVal; i++) {
        let isAxis = (i === 0);
        let stroke = isAxis ? "#333" : "#e0e0e0";
        let width = isAxis ? 2 : 1;
        
        svg += `<line x1="${scaleX(i)}" y1="${scaleY(minVal)}" x2="${scaleX(i)}" y2="${scaleY(maxVal)}" stroke="${stroke}" stroke-width="${width}"/>`;
        svg += `<line x1="${scaleX(minVal)}" y1="${scaleY(i)}" x2="${scaleX(maxVal)}" y2="${scaleY(i)}" stroke="${stroke}" stroke-width="${width}"/>`;
        
        // Labels
        if(i !== 0 && i % 2 === 0 && Math.abs(i) !== 6) { 
             // Only show even numbers to reduce clutter, but keep grid lines 1:1
             // X Labels
             svg += `<text x="${scaleX(i)}" y="${scaleY(0) + 15}" text-anchor="middle" class="tick-text">${i}</text>`;
             // Y Labels
             svg += `<text x="${scaleX(0) - 6}" y="${scaleY(i) + 4}" text-anchor="end" class="tick-text">${i}</text>`;
        }
    }

    // Line Calculation
    let x1 = minVal, y1 = m * minVal + b;
    let x2 = maxVal, y2 = m * maxVal + b;
    
    // Shading
    let shadePoints = "";
    const isGreater = (symbol.includes(">") || symbol.includes("≥"));
    
    if (isGreater) {
        shadePoints = `${scaleX(x1)},${scaleY(y1)} ${scaleX(x2)},${scaleY(y2)} ${scaleX(maxVal)},${scaleY(maxVal)} ${scaleX(minVal)},${scaleY(maxVal)}`;
    } else {
        shadePoints = `${scaleX(x1)},${scaleY(y1)} ${scaleX(x2)},${scaleY(y2)} ${scaleX(maxVal)},${scaleY(minVal)} ${scaleX(minVal)},${scaleY(minVal)}`;
    }

    svg += `<polygon points="${shadePoints}" fill="rgba(52, 152, 219, 0.3)" />`;

    // Line Style
    let dashArray = (symbol === "<" || symbol === ">") ? "10,6" : "0"; 
    svg += `<line x1="${scaleX(x1)}" y1="${scaleY(y1)}" x2="${scaleX(x2)}" y2="${scaleY(y2)}" stroke="#2980b9" stroke-width="3" stroke-dasharray="${dashArray}" />`;

    svg += `</svg>`;
    return svg;
}

// --- QUESTION GENERATORS ---

// Q1: Match Inequality to Graph (Multiple Choice Graphs)
function genQ_MatchGraph() {
    let m = pick([-2, -1, 1, 2]); 
    let b = randInt(-3, 3);
    let sym = pick(["<", ">", "≤", "≥"]);
    
    let eq = fmtEq(m, b, sym);
    
    // We need unique graph parameters (m, b, sym)
    // We use the same strategy logic but return objects for graph generation
    let options = [];
    
    // 1. Correct
    options.push({ id: 0, svg: generateGraph(m, b, sym), correct: true });
    
    // 2. Generate Distractors parameters
    let paramsSet = new Set();
    paramsSet.add(`${m}|${b}|${sym}`);
    
    let strategies = [
        () => ({ m: m, b: b, s: (sym.includes('<') ? sym.replace('<', '>') : sym.replace('>', '<')) }), // Flip Shade
        () => ({ m: -m, b: b, s: sym }), // Flip Slope
        () => ({ m: m, b: (b===0 ? 2 : -b), s: sym }), // Flip Intercept
        () => ({ m: m, b: b, s: (sym==='<'?'≤': (sym==='≤'?'<': (sym==='>'?'≥':'>'))) }) // Flip Style
    ];
    
    let distIdx = 1;
    for(let strat of strategies) {
        if(options.length >= 4) break;
        let p = strat();
        let key = `${p.m}|${p.b}|${p.s}`;
        
        if(!paramsSet.has(key)) {
            paramsSet.add(key);
            options.push({ id: distIdx++, svg: generateGraph(p.m, p.b, p.s), correct: false });
        }
    }
    
    options.sort(() => Math.random() - 0.5);

    return {
        type: "graph-select",
        text: `Which graph represents: <div style="text-align:center; margin:10px; font-size:1.4em;" class="math-text">${eq}</div>`,
        options: options,
        explanation: `<b>Analysis:</b><br>
        1. <b>Slope:</b> ${m}.<br>
        2. <b>Y-Intercept:</b> ${b}.<br>
        3. <b>Line:</b> ${sym.includes('=') ? 'Solid' : 'Dashed'}.<br>
        4. <b>Shade:</b> ${sym.includes('<') ? 'Below' : 'Above'}.`
    };
}

// Q2: Match Graph to Inequality (Text Options - The one that had duplicates)
function genQ_MatchText() {
    let m = pick([-2, -1, 1, 2]); 
    let b = randInt(-2, 2);
    let sym = pick(["<", ">", "≤", "≥"]);
    
    let correctEq = fmtEq(m, b, sym);
    let graph = generateGraph(m, b, sym, 280);
    
    // Use Robust Deduper
    let distractors = generateDistractors(m, b, sym);
    
    let opts = [
        { text: correctEq, correct: true },
        { text: distractors[0].text, correct: false },
        { text: distractors[1].text, correct: false },
        { text: distractors[2].text, correct: false }
    ];
    
    opts.sort(() => Math.random() - 0.5);

    return {
        type: "text-select",
        text: `Which inequality matches the graph?<br>${graph}`,
        options: opts,
        explanation: `Look at the graph:<br>
        - Intercepts at ${b}<br>
        - Slope is ${m}<br>
        - Shading is ${sym.includes('<') ? 'Below' : 'Above'}<br>
        Correct: ${correctEq}`
    };
}

// Q3: Point Check
function genQ_PointCheck() {
    let m = randInt(-3, 3);
    let b = randInt(-4, 4);
    let sym = pick(["<", ">", "≤", "≥"]);
    let px = randInt(-4, 4);
    let py = randInt(-4, 4);
    
    // Ensure point is not exactly on line for clarity
    while(py === m*px + b) { py = randInt(-4, 4); }
    
    let lhs = py;
    let rhs = m*px + b;
    let isSol = false;
    if(sym === "<") isSol = lhs < rhs;
    if(sym === ">") isSol = lhs > rhs;
    if(sym === "≤") isSol = lhs <= rhs;
    if(sym === "≥") isSol = lhs >= rhs;
    
    let eq = fmtEq(m, b, sym);
    
    return {
        type: "bool",
        text: `Is point <span class="math-text">(${px}, ${py})</span> a solution to <span class="math-text">${eq}</span>?`,
        answer: isSol,
        explanation: `Substitute x=${px}, y=${py}:<br>
        ${py} ${sym} ${m}(${px}) ${b>=0?'+ '+b:b}<br>
        ${py} ${sym} ${m*px + b}<br>
        This is <b>${isSol}</b>.`
    };
}

// --- RENDER LOGIC ---

function startNewQuiz() {
    score = 0;
    currentQIndex = 0;
    document.getElementById('summary-area').classList.add('hidden');
    document.getElementById('quiz-area').classList.remove('hidden');
    document.getElementById('score-correct').innerText = "0";
    renderQuestion();
}

function nextQuestion() {
    currentQIndex++;
    if (currentQIndex < TOTAL_QUESTIONS) {
        renderQuestion();
    } else {
        document.getElementById('quiz-area').classList.add('hidden');
        document.getElementById('summary-area').classList.remove('hidden');
        document.getElementById('final-score').innerText = score + "/" + TOTAL_QUESTIONS;
    }
}

function renderQuestion() {
    const contentDiv = document.getElementById('dynamic-content');
    contentDiv.innerHTML = "";
    document.getElementById('q-num').innerText = currentQIndex + 1;
    document.getElementById('feedback-area').style.display = 'none';
    document.getElementById('submit-btn').classList.remove('hidden');
    document.getElementById('next-btn').classList.add('hidden');

    const type = randInt(0, 2); 
    if(type === 0) currentQData = genQ_MatchGraph();
    else if(type === 1) currentQData = genQ_MatchText();
    else currentQData = genQ_PointCheck();

    document.getElementById('question-text').innerHTML = currentQData.text;

    if (currentQData.type === 'graph-select') {
        let grid = document.createElement('div');
        grid.className = 'graph-grid';
        currentQData.options.forEach((opt, idx) => {
            let div = document.createElement('div');
            div.className = 'graph-option';
            div.innerHTML = opt.svg + `<div class="graph-label">Option ${String.fromCharCode(65+idx)}</div>`;
            div.dataset.id = idx;
            div.onclick = () => {
                document.querySelectorAll('.graph-option').forEach(el => el.classList.remove('selected'));
                div.classList.add('selected');
            };
            grid.appendChild(div);
        });
        contentDiv.appendChild(grid);
    }
    else if (currentQData.type === 'text-select') {
        let container = document.createElement('div');
        container.className = 'mc-container';
        currentQData.options.forEach((opt, idx) => {
            let div = document.createElement('div');
            div.className = 'mc-text-option';
            div.innerHTML = `<span class="mc-letter">${String.fromCharCode(65+idx)}</span> ${opt.text}`;
            div.dataset.id = idx;
            div.onclick = () => {
                document.querySelectorAll('.mc-text-option').forEach(el => el.classList.remove('selected'));
                div.classList.add('selected');
            };
            container.appendChild(div);
        });
        contentDiv.appendChild(container);
    }
    else if (currentQData.type === 'bool') {
        contentDiv.innerHTML = `
            <div class="btn-group">
                <button class="btn secondary" onclick="selectBool(true, this)">YES</button>
                <button class="btn secondary" onclick="selectBool(false, this)">NO</button>
            </div>
            <input type="hidden" id="user-bool">
        `;
    }
}

function selectBool(val, btn) {
    document.getElementById('user-bool').value = val;
    const btns = btn.parentElement.querySelectorAll('button');
    btns.forEach(b => {
        b.style.backgroundColor = '#95a5a6';
        b.style.color = 'white';
    });
    btn.style.backgroundColor = '#3498db';
}

function checkAnswer() {
    let isCorrect = false;

    if (currentQData.type === 'graph-select') {
        const selected = document.querySelector('.graph-option.selected');
        if (selected && currentQData.options[selected.dataset.id].correct) isCorrect = true;
    }
    else if (currentQData.type === 'text-select') {
        const selected = document.querySelector('.mc-text-option.selected');
        if (selected && currentQData.options[selected.dataset.id].correct) isCorrect = true;
    }
    else if (currentQData.type === 'bool') {
        const val = document.getElementById('user-bool').value;
        if(val !== "" && (val === 'true') === currentQData.answer) isCorrect = true;
    }

    const feedback = document.getElementById('feedback-area');
    feedback.style.display = 'block';
    feedback.className = 'feedback ' + (isCorrect ? 'correct' : 'incorrect');
    document.getElementById('feedback-title').innerText = isCorrect ? "Correct!" : "Incorrect";
    document.getElementById('solution-text').innerHTML = currentQData.explanation;
    
    if (isCorrect) {
        score++;
        document.getElementById('score-correct').innerText = score;
    }
    
    document.getElementById('submit-btn').classList.add('hidden');
    document.getElementById('next-btn').classList.remove('hidden');
}

startNewQuiz();

</script>
</body>
</html>